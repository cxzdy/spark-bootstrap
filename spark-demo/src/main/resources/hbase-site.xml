<?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="configuration.xsl"?>

<configuration>
  <!--Configs you will likely change are listed here at the top of the file.
  -->
  <property >
    <name>hbase.tmp.dir</name>
    <value>/data/hbase/tmp/hbase-${user.name}</value>
    <description>Temporary directory on the local filesystem.
    Change this setting to point to a location more permanent
    than '/tmp', the usual resolve for java.io.tmpdir, as the
    '/tmp' directory is cleared on machine restart.</description>
  </property>
  <property >
    <name>hbase.rootdir</name>
    <value>hdfs://ss-hadoop/hbase</value>
    <description>The directory shared by region servers and into
    which HBase persists.  The URL should be 'fully-qualified'
    to include the filesystem scheme.  For example, to specify the
    HDFS directory '/hbase' where the HDFS instance's namenode is
    running at namenode.example.org on port 9000, set this value to:
    hdfs://namenode.example.org:9000/hbase.  By default, we write
    to whatever ${hbase.tmp.dir} is set too -- usually /tmp --
    so change this configuration or else all data will be lost on
    machine restart.</description>
  </property>
  <property >
    <name>hbase.cluster.distributed</name>
    <value>true</value>
    <description>The mode the cluster will be in. Possible values are
      false for standalone mode and true for distributed mode.  If
      false, startup will run all HBase and ZooKeeper daemons together
      in the one JVM.</description>
  </property>
  <property>
    <name>hbase.zookeeper.quorum</name>
    <value>nn7ss.prod.mediav.com,nn8ss.prod.mediav.com,nn9ss.prod.mediav.com</value>
    <description>Comma separated list of servers in the ZooKeeper ensemble
    (This config. should have been named hbase.zookeeper.ensemble).
    For example, "host1.mydomain.com,host2.mydomain.com,host3.mydomain.com".
    By default this is set to localhost for local and pseudo-distributed modes
    of operation. For a fully-distributed setup, this should be set to a full
    list of ZooKeeper ensemble servers. If HBASE_MANAGES_ZK is set in hbase-env.sh
    this is the list of servers which hbase will start/stop ZooKeeper on as
    part of cluster start/stop.  Client-side, we will take this list of
    ensemble members and put it together with the hbase.zookeeper.clientPort
    config. and pass it into zookeeper constructor as the connectString
    parameter.</description>
  </property>

  <property>
    <name>hbase.master.loadbalancer.class</name>
    <value>org.apache.hadoop.hbase.master.balancer.StochasticLoadBalancer</value>
    <description>
      Class used to execute the regions balancing when the period occurs.
      See the class comment for more on how it works
      http://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/master/balancer/StochasticLoadBalancer.html
      It replaces the DefaultLoadBalancer as the default (since renamed
      as the SimpleLoadBalancer).
    </description>
  </property>

  <!--RegionServer configurations-->
  <property>
    <name>hbase.regionserver.handler.count</name>
    <value>100</value>
    <description>Count of RPC Listener instances spun up on RegionServers.
    Same property is used by the Master for count of master handlers.</description>
  </property>
  <property>
    <name>hbase.regionserver.regionSplitLimit</name>
    <value>2147483647</value>
    <description>Limit for the number of regions after which no more region
    splitting should take place. This is not a hard limit for the number of
    regions but acts as a guideline for the regionserver to stop splitting after
    a certain limit. Default is MAX_INT; i.e. do not block splitting.</description>
  </property>
  <property>
    <name>hbase.regionserver.region.split.policy</name>
    <value>org.apache.hadoop.hbase.regionserver.IncreasingToUpperBoundRegionSplitPolicy</value>
    <description>
      A split policy determines when a region should be split. The various other split policies that
      are available currently are ConstantSizeRegionSplitPolicy, DisabledRegionSplitPolicy,
      DelimitedKeyPrefixRegionSplitPolicy, KeyPrefixRegionSplitPolicy etc.
    </description>
  </property>
  <property>
    <name>hbase.regionserver.regionSplitLimit</name>
    <value>1000</value>
    <description>
      Limit for the number of regions after which no more region splitting should take place.
      This is not hard limit for the number of regions but acts as a guideline for the regionserver
      to stop splitting after a certain limit. Default is set to 1000.
    </description>
  </property>

  <!--ZooKeeper configuration-->
  <property>
    <name>zookeeper.session.timeout</name>
    <value>90000</value>
    <description>ZooKeeper session timeout in milliseconds. It is used in two different ways.
      First, this value is used in the ZK client that HBase uses to connect to the ensemble.
      It is also used by HBase when it starts a ZK server and it is passed as the 'maxSessionTimeout'. See
      http://hadoop.apache.org/zookeeper/docs/current/zookeeperProgrammers.html#ch_zkSessions.
      For example, if a HBase region server connects to a ZK ensemble that's also managed by HBase, then the
      session timeout will be the one specified by this configuration. But, a region server that connects
      to an ensemble managed with a different configuration will be subjected that ensemble's maxSessionTimeout. So,
      even though HBase might propose using 90 seconds, the ensemble can have a max timeout lower than this and
      it will take precedence. The current default that ZK ships with is 40 seconds, which is lower than HBase's.
    </description>
  </property>
  <property>
    <name>hbase.zookeeper.property.dataDir</name>
    <value>/data/hbase/zookeeper</value>
    <description>Property from ZooKeeper's config zoo.cfg.
    The directory where the snapshot is stored.</description>
  </property>
  <property>
    <name>hbase.zookeeper.property.clientPort</name>
    <value>2181</value>
    <description>Property from ZooKeeper's config zoo.cfg.
    The port at which the clients will connect.</description>
  </property>
  <property>
    <name>hbase.zookeeper.property.maxClientCnxns</name>
    <value>300</value>
    <description>Property from ZooKeeper's config zoo.cfg.
    Limit on number of concurrent connections (at the socket level) that a
    single client, identified by IP address, may make to a single member of
    the ZooKeeper ensemble. Set high to avoid zk connection issues running
    standalone and pseudo-distributed.</description>
  </property>
  <!-- End of properties that are directly mapped from ZooKeeper's zoo.cfg -->

  <!--Client configurations-->
  <property>
    <name>hbase.client.write.buffer</name>
    <value>2097152</value>
    <description>Default size of the HTable client write buffer in bytes.
    A bigger buffer takes more memory -- on both the client and server
    side since server instantiates the passed write buffer to process
    it -- but a larger buffer size reduces the number of RPCs made.
    For an estimate of server-side memory-used, evaluate
    hbase.client.write.buffer * hbase.regionserver.handler.count</description>
  </property>
  <property>
    <name>hbase.client.pause</name>
    <value>100</value>
    <description>General client pause value.  Used mostly as value to wait
    before running a retry of a failed get, region lookup, etc.
    See hbase.client.retries.number for description of how we backoff from
    this initial pause amount and how this pause works w/ retries.</description>
  </property>
  <property>
    <name>hbase.client.retries.number</name>
    <value>35</value>
    <description>Maximum retries.  Used as maximum for all retryable
    operations such as the getting of a cell's value, starting a row update,
    etc.  Retry interval is a rough function based on hbase.client.pause.  At
    first we retry at this interval but then with backoff, we pretty quickly reach
    retrying every ten seconds.  See HConstants#RETRY_BACKOFF for how the backup
    ramps up.  Change this setting and hbase.client.pause to suit your workload.</description>
  </property>
  <property>
    <name>hbase.client.max.total.tasks</name>
    <value>100</value>
    <description>The maximum number of concurrent tasks a single HTable instance will
    send to the cluster.</description>
  </property>
  <property>
    <name>hbase.client.max.perserver.tasks</name>
    <value>5</value>
    <description>The maximum number of concurrent tasks a single HTable instance will
    send to a single region server.</description>
  </property>
  <property>
    <name>hbase.client.max.perregion.tasks</name>
    <value>1</value>
    <description>The maximum number of concurrent connections the client will
    maintain to a single Region. That is, if there is already
    hbase.client.max.perregion.tasks writes in progress for this region, new puts
    won't be sent to this region until some writes finishes.</description>
  </property>
  <property>
    <name>hbase.client.scanner.caching</name>
    <value>2147483647</value>
    <description>Number of rows that we try to fetch when calling next
    on a scanner if it is not served from (local, client) memory. This configuration
    works together with hbase.client.scanner.max.result.size to try and use the
    network efficiently. The default value is Integer.MAX_VALUE by default so that
    the network will fill the chunk size defined by hbase.client.scanner.max.result.size
    rather than be limited by a particular number of rows since the size of rows varies
    table to table. If you know ahead of time that you will not require more than a certain
    number of rows from a scan, this configuration should be set to that row limit via
    Scan#setCaching. Higher caching values will enable faster scanners but will eat up more
    memory and some calls of next may take longer and longer times when the cache is empty.
    Do not set this value such that the time between invocations is greater than the scanner
    timeout; i.e. hbase.client.scanner.timeout.period</description>
  </property>
  <property>
    <name>hbase.client.keyvalue.maxsize</name>
    <value>10485760</value>
    <description>Specifies the combined maximum allowed size of a KeyValue
    instance. This is to set an upper boundary for a single entry saved in a
    storage file. Since they cannot be split it helps avoiding that a region
    cannot be split any further because the data is too large. It seems wise
    to set this to a fraction of the maximum region size. Setting it to zero
    or less disables the check.</description>
  </property>
  <property>
    <name>hbase.client.scanner.timeout.period</name>
    <value>60000</value>
    <description>Client scanner lease period in milliseconds.</description>
  </property>
  <property>
    <name>hbase.client.localityCheck.threadPoolSize</name>
    <value>2</value>
  </property>

  <!--Miscellaneous configuration-->
  <property>
    <name>hbase.bulkload.retries.number</name>
    <value>10</value>
    <description>Maximum retries.  This is maximum number of iterations
    to atomic bulk loads are attempted in the face of splitting operations
    0 means never give up.</description>
  </property>
  <property>
    <name>hbase.balancer.period</name>
    <value>300000</value>
    <description>Period at which the region balancer runs in the Master.</description>
  </property>
  <property>
    <name>hbase.hregion.memstore.flush.size</name>
    <value>1073741824</value>
    <description>
    Memstore will be flushed to disk if size of the memstore
    exceeds this number of bytes.  Value is checked by a thread that runs
    every hbase.server.thread.wakefrequency.</description>
  </property>
  <property>
    <name>hbase.hregion.percolumnfamilyflush.size.lower.bound</name>
    <value>268435456</value>
    <description>
    If FlushLargeStoresPolicy is used, then every time that we hit the
    total memstore limit, we find out all the column families whose memstores
    exceed this value, and only flush them, while retaining the others whose
    memstores are lower than this limit. If none of the families have their
    memstore size more than this, all the memstores will be flushed
    (just as usual). This value should be less than half of the total memstore
    threshold (hbase.hregion.memstore.flush.size).
    </description>
  </property>
  <property>
    <name>hbase.hregion.preclose.flush.size</name>
    <value>5242880</value>
    <description>
      If the memstores in a region are this size or larger when we go
      to close, run a "pre-flush" to clear out memstores before we put up
      the region closed flag and take the region offline.  On close,
      a flush is run under the close flag to empty memory.  During
      this time the region is offline and we are not taking on any writes.
      If the memstore content is large, this flush could take a long time to
      complete.  The preflush is meant to clean out the bulk of the memstore
      before putting up the close flag and taking the region offline so the
      flush that runs under the close flag has little to do.</description>
  </property>
  <property>
    <name>hbase.hregion.memstore.block.multiplier</name>
    <value>4</value>
    <description>
    Block updates if memstore has hbase.hregion.memstore.block.multiplier
    times hbase.hregion.memstore.flush.size bytes.  Useful preventing
    runaway memstore during spikes in update traffic.  Without an
    upper-bound, memstore fills such that when it flushes the
    resultant flush files take a long time to compact or split, or
    worse, we OOME.</description>
  </property>
  <property>
    <name>hbase.hregion.memstore.mslab.enabled</name>
    <value>true</value>
    <description>
      Enables the MemStore-Local Allocation Buffer,
      a feature which works to prevent heap fragmentation under
      heavy write loads. This can reduce the frequency of stop-the-world
      GC pauses on large heaps.</description>
  </property>
  <property>
    <name>hbase.hregion.max.filesize</name>
    <value>10737418240</value>
    <description>
    Maximum HStoreFile size. If any one of a column families' HStoreFiles has
    grown to exceed this value, the hosting HRegion is split in two.</description>
  </property>
  <property>
    <name>hbase.hregion.majorcompaction</name>
    <value>604800000</value>
    <description>The time (in miliseconds) between 'major' compactions of all
    HStoreFiles in a region.  Default: Set to 7 days.  Major compactions tend to
    happen exactly when you need them least so enable them such that they run at
    off-peak for your deploy; or, since this setting is on a periodicity that is
    unlikely to match your loading, run the compactions via an external
    invocation out of a cron job or some such.</description>
  </property>
  <property>
    <name>hbase.hregion.majorcompaction.jitter</name>
    <value>0.50</value>
    <description>Jitter outer bound for major compactions.
    On each regionserver, we multiply the hbase.region.majorcompaction
    interval by some random fraction that is inside the bounds of this
    maximum.  We then add this + or - product to when the next
    major compaction is to run.  The idea is that major compaction
    does happen on every regionserver at exactly the same time.  The
    smaller this number, the closer the compactions come together.</description>
  </property>
  <property>
    <name>hbase.hstore.compactionThreshold</name>
    <value>3</value>
    <description>
    If more than this number of HStoreFiles in any one HStore
    (one HStoreFile is written per flush of memstore) then a compaction
    is run to rewrite all HStoreFiles files as one.  Larger numbers
    put off compaction but when it runs, it takes longer to complete.</description>
  </property>
  <property>
    <name>hbase.hstore.flusher.count</name>
    <value>2</value>
    <description>
    The number of flush threads. With less threads, the memstore flushes will be queued. With
    more threads, the flush will be executed in parallel, increasing the hdfs load. This can
    lead as well to more compactions.
    </description>
  </property>
  <property>
    <name>hbase.hstore.blockingStoreFiles</name>
    <value>10</value>
    <description>
    If more than this number of StoreFiles in any one Store
    (one StoreFile is written per flush of MemStore) then updates are
    blocked for this HRegion until a compaction is completed, or
    until hbase.hstore.blockingWaitTime has been exceeded.</description>
  </property>
  <property>
    <name>hbase.hstore.blockingWaitTime</name>
    <value>90000</value>
    <description>
    The time an HRegion will block updates for after hitting the StoreFile
    limit defined by hbase.hstore.blockingStoreFiles.
    After this time has elapsed, the HRegion will stop blocking updates even
    if a compaction has not been completed.</description>
  </property>
  <property>
    <name>hbase.hstore.compaction.max</name>
    <value>10</value>
    <description>Max number of HStoreFiles to compact per 'minor' compaction.</description>
  </property>
  <property>
    <name>hbase.hstore.compaction.kv.max</name>
    <value>10</value>
    <description>How many KeyValues to read and then write in a batch when flushing
        or compacting.  Do less if big KeyValues and problems with OOME.
        Do more if wide, small rows.</description>
  </property>
  <property>
    <name>hbase.hstore.time.to.purge.deletes</name>
    <value>0</value>
    <description>The amount of time to delay purging of delete markers with future timestamps. If 
      unset, or set to 0, all delete markers, including those with future timestamps, are purged 
      during the next major compaction. Otherwise, a delete marker is kept until the major compaction 
      which occurs after the marker's timestamp plus the value of this setting, in milliseconds.
    </description>
  </property>
  <property>
    <name>hbase.storescanner.parallel.seek.enable</name>
    <value>false</value>
    <description>
      Enables StoreFileScanner parallel-seeking in StoreScanner,
      a feature which can reduce response latency under special conditions.</description>
  </property>
  <property>
    <name>hbase.storescanner.parallel.seek.threads</name>
    <value>10</value>
    <description>
      The default thread pool size if parallel-seeking feature enabled.</description>
  </property>
  <property>
    <name>hfile.block.cache.size</name>
    <value>0.2</value>
    <description>Percentage of maximum heap (-Xmx setting) to allocate to block cache
        used by HFile/StoreFile. Default of 0.4 means allocate 40%.
        Set to 0 to disable but it's not recommended; you need at least
        enough cache to hold the storefile indices.</description>
  </property>
  <property>
      <name>hfile.block.index.cacheonwrite</name>
      <value>false</value>
      <description>This allows to put non-root multi-level index blocks into the block
          cache at the time the index is being written.</description>
  </property>
  <property>
      <name>hfile.index.block.max.size</name>
      <value>131072</value>
      <description>When the size of a leaf-level, intermediate-level, or root-level
          index block in a multi-level block index grows to this size, the
          block is written out and a new block is started.</description>
  </property>
  <property>
      <name>hfile.format.version</name>
      <value>2</value>
      <description>The HFile format version to use for new files.
      Version 3 adds support for tags in hfiles (See http://hbase.apache.org/book.html#hbase.tags).
      Distributed Log Replay requires that tags are enabled. Also see the configuration
      'hbase.replication.rpc.codec'.
      By default CDH5 uses HFileV2 for backward compatibility
      purposes.
      </description>
  </property>
  <property>
      <name>hfile.block.bloom.cacheonwrite</name>
      <value>false</value>
      <description>Enables cache-on-write for inline blocks of a compound Bloom filter.</description>
  </property>
  <property>
      <name>io.storefile.bloom.block.size</name>
      <value>131072</value>
      <description>The size in bytes of a single block ("chunk") of a compound Bloom
          filter. This size is approximate, because Bloom blocks can only be
          inserted at data block boundaries, and the number of keys per data
          block varies.</description>
  </property>
  <property>
      <name>hbase.rs.cacheblocksonwrite</name>
      <value>false</value>
      <description>Whether an HFile block should be added to the block cache when the
          block is finished.</description>
  </property>

  <property>
    <name>hbase.coprocessor.region.classes</name>
    <value></value>
    <description>A comma-separated list of Coprocessors that are loaded by
    default on all tables. For any override coprocessor method, these classes
    will be called in order. After implementing your own Coprocessor, just put
    it in HBase's classpath and add the fully qualified class name here.
    A coprocessor can also be loaded on demand by setting HTableDescriptor.</description>
  </property>
  <property>
    <name>hbase.coprocessor.master.classes</name>
    <value></value>
    <description>A comma-separated list of
    org.apache.hadoop.hbase.coprocessor.MasterObserver coprocessors that are
    loaded by default on the active HMaster process. For any implemented
    coprocessor methods, the listed classes will be called in order. After
    implementing your own MasterObserver, just put it in HBase's classpath
    and add the fully qualified class name here.</description>
  </property>
  <property>
      <name>hbase.coprocessor.abortonerror</name>
      <value>true</value>
      <description>Set to true to cause the hosting server (master or regionserver)
      to abort if a coprocessor fails to load, fails to initialize, or throws an
      unexpected Throwable object. Setting this to false will allow the server to
      continue execution but the system wide state of the coprocessor in question
      will become inconsistent as it will be properly executing in only a subset
      of servers, so this is most useful for debugging only.</description>
  </property>

  <property>
    <name>hbase.online.schema.update.enable</name>
    <value>true</value>
    <description>Set true to enable online schema changes.</description>
  </property>
  <property>
    <name>hbase.table.lock.enable</name>
    <value>true</value>
    <description>Set to true to enable locking the table in zookeeper for schema change operations.
    Table locking from master prevents concurrent schema modifications to corrupt table
    state.</description>
  </property>
  <property>
    <name>hbase.table.max.rowsize</name>
    <value>1073741824</value>
    <description>
      Maximum size of single row in bytes (default is 1 Gb) for Get'ting
      or Scan'ning without in-row scan flag set. If row size exceeds this limit
      RowTooBigException is thrown to client.
    </description>
  </property>
  
  <property>
    <name>hbase.snapshot.enabled</name>
    <value>true</value>
    <description>Set to true to allow snapshots to be taken / restored / cloned.</description>
  </property>
  <property>
    <name>hbase.snapshot.restore.take.failsafe.snapshot</name>
    <value>true</value>
    <description>Set to true to take a snapshot before the restore operation.
      The snapshot taken will be used in case of failure, to restore the previous state.
      At the end of the restore operation this snapshot will be deleted</description>
  </property>
  <property>
    <name>hbase.snapshot.restore.failsafe.name</name>
    <value>hbase-failsafe-{snapshot.name}-{restore.timestamp}</value>
    <description>Name of the failsafe snapshot taken by the restore operation.
      You can use the {snapshot.name}, {table.name} and {restore.timestamp} variables
      to create a name based on what you are restoring.</description>
  </property>

  <property>
    <name>dfs.support.append</name>
    <value>true</value>
  </property>
</configuration>
